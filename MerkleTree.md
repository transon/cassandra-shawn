Merkle Tree, 又被称为Hash Tree，是一种树状Hash结构，1979年由Ralph Merkle发明。

如前面的blog所述，Merkle Tree 首次在NoSQL存储系统中的应用是在Amazon的Dynamo上。对于分布式的存储系统，可以说同步是最为重要的话题。本质上来说，关系型数据库的ACID特性和目前NoSQL存储系统的BASE特性，核心的差异就在于对同步的理解上。关系型数据库通过同步的原子性来保证强一致性，这在单个服务器环境下是可以接受的，但是当应用到分布式环境时，这个策略带来的后果是灾难性的。锁的代价让分布式系统难以在保证强一致性的同时做到高效率，所以，最终一致性代替强一致性称为了分布式系统的选择。

但是，最终一致性仍然是由时间跨度比较大的同步操作来保证的。如果在Dynamo中出现了不一致，比如其中的一个节点在down掉一段时间后再次上线，这时首先需要对其数据进行一个“去熵（anti-entropy）”操作，实际上就是一个对不同节点上共有的数据副本进行同步的操作。为了让非常贵的同步操作尽可能的高效，Merkle Tree便被引入了进来。

Merkle Tree（MT）是一个非常容易理解的数据结构，简单来说就是一颗hash树，在这棵树中，叶子节点的值是一些hash值、非叶节点的值均是由其子节点值计算hash得来的。在Dynamo中，每个节点保存一个范围内的key值，不同节点间存在有相互交迭的key值范围。在去熵操作中，考虑的仅仅是某两个节点间共有的key值范围。MT的叶子节点即是这个共有的key值范围内每个key的hash，通过叶子节点的hash自底向上便可以构建出一颗MT。 Dynamo首先比对MT根处的hash，如果一致则表示两者完全一致，否则将其子节点交换并继续比较的过程。

使用MT的好处无非从时间和空间两个角度考虑，在分布式情况下，空间可以理解为相应的网络传输数据量。

在时间上，MT利用树形结构避免了可能出现的线性时间比较，迅速定位到差异的key值，时间复杂度为O（lgn）；

在网络传输上，如果进行线性比对，每次必须将共有的key值范围内所有hash传输，但针对MT而言，是查到哪一层，获取哪一层需要的hash值，大大减小了传输数据量。（一个早期应用MT的例子便是在bt下载软件中，为了避免所有数据块的hash都必须存在torrent中导致tracker的巨大压力，从而使用MT这种数据结构，并且只需将根处hash存放到torrent中。）

此外，与MT类似的数据结构，还包括线段树，这也是一个非常有趣的数据结构，有时间大家也可以稍作研究。

Source: http://ultimatearchitecture.net/index.php/2010/09/12/merkle-tree/
> BitTorrent中的数据块校验方式改进 -- Merkle Hashing Tree：http://blog.csdn.net/starxu85/archive/2009/02/02/3859011.aspx